# ORM

## **ЧТО ТАКОЕ ORM?**

*ORM* *(Object* *Relational* *Mapping,* *объектно-реляционное**отображение)* — это технология, которая позволяет работать с базамиданных так, как если бы это были объекты из языков программирования.Вместо написания SQL-запросов вручную, разработчик оперирует объектами и классами, а ОРМ автоматически транслирует их в SQL. Это значит, чторазработчик может взаимодействовать с базой данных, используя привычные конструкции языка программирования.

## **В ЧЕМ СУТЬ?**

Суть ORM заключается в том, что данные из таблиц базы данных отображаются на объекты в коде, а изменения этих объектов синхронизируются с базой данных.

Пример: у нас есть таблица пользователей в базе данных. ORM позволяет создать класс *User*, каждый экземпляр которого будет представлять строку из этой таблицы.

Когда необходимо получить пользователя с определённым идентификатором, ORM автоматически сформирует соответствующий SQL-запрос, выполнит его и вернёт объект класса *User* с данными из базы.

## **ЗАДАЧИ ORM**

#### Сопоставление классов и таблиц:

ORM берет класс из объектно-ориентированного языка программирования (например, Python, Java или C#) и сопоставляет его с таблицей в реляционной базе данных. Каждое свойство (атрибут) класса соответствует столбцу в таблице, а каждый объект этого класса — отдельной строке (записи) в таблице.

Пример:
Класс на Python:
```python
class User:
    id = int
    name = str
    email = str
```

Таблица в базе данных:

| id  | name  | email                     |
|:----|:------|:--------------------------|
| 1   | Asya  | AsyaTihonechko@gmail.com  |
| 2   | Kvatya| Katatish@mail.ru          |

ORM автоматически устанавливает это соответствие, чтобы можно было работать с таблицей как с обычным классом в коде.

#### Автоматическая генерация SQL-запросов:

ORM самостоятельно формирует необходимые SQL-запросы (INSERT, SELECT, UPDATE, DELETE) на основе операций с объектами в коде. Вместо того чтобы вручную писать SQL-код, программист работает с объектами, а ORM «под капотом» формирует и выполняет соответствующий SQL.

Пример:
Вместо:
 ```sql
 SELECT FROM users WHERE id = 1;
 ```

Используется:
```python
user = session.query(User).get(1)
```

А ORM сам составляет и отправляет нужный SQL-запрос в базу. Это упрощает работу, уменьшает количество ошибок и делает код более читаемым.

#### Выполнение CRUD-операций (Create, Read, Update, Delete):

ORM позволяет выполнять все основные операции с базой данных через работу с объектами:

- Create — создание новых записей (объектов)
- Read — получение данных из базы (чтение)
- Update — изменение уже существующих данных
- Delete — удаление данных

Create (создание)
```python
new_user = User(name="Леонид", email="BigLenchik@mail.com")
session.add(new_user)
session.commit()

```

ORM создаст SQL-запрос:
```sql
INSERT INTO users (name, email)
VALUES ('Леонид', 'BigLenchik@mail.com');
```

Read (чтение)
```python 
user = session.query(User).get(1)
```
ORM выполнит SQL-запрос:
```sql
SELECT FROM users WHERE id = 1
```

Update (обновление)
```python
user.name = "Леня"
session.commit()
```
ORM выполнит:
```sql
UPDATE users SET name='Леня' WHERE id=1
```

Delete (удаление)
```python
session.delete(user)
session.commit()
```
ORM выполнит:
```sql 
DELETE FROM users WHERE id=1
```

#### Управление связями между объектами (один-к-одному, один-ко-многим,* многие-ко-многим):

ORM позволяет удобно задавать и поддерживать связи между таблицами в базе данных, используя объектные отношения. Это нужно для работы со сложными структурами данных, где один объект может быть связан с другим или с несколькими.

Типы связей:

- Один-к-одному (One-to-One): Один объект соответствует только одному другому объекту.(Один пользователь — один профиль).
- Один-ко-многим (One-to-Many): Один объект связан с несколькими другими. (Один автор может иметь несколько книг).
- Многие-ко-многим (Many-to-Many): Несколько объектов могут быть связаны с несколькими другими. (Студенты и курсы: один студент может посещать несколько курсов, и один курс может иметь много студентов).

В ORM связь между объектами настраивается через специальные поля и методы.
```python
class Author(Base):
    books = relationship("Book", back_populates="author")



class Book(Base):
    author_id = Column(Integer, ForeignKey("author.id"))
    author = relationship("Author", back_populates="books")
```

Всё это позволяет автоматически подхватывать связи между объектами без необходимости вручную писать JOIN-запросы.

## **ПРЕИМУЩЕСТВА ORM**

#### Повышает производительность разработки за счёт уменьшения объёма кода для работы с базой данных:

Без ORM приходится писать много ручных SQL-запросов, обрабатывать результаты, вручную формировать запросы для вставки, изменения или удаления данных. ORM автоматизирует эти процессы, позволяя писать меньше кода на Python или другом языке, и не отвлекаться на составление SQL.

#### Cнижает вероятность ошибок в SQL-запросах:

Когда запросы пишутся вручную, легко допустить синтаксическую или логическую ошибку (опечатка в названии таблицы, неправильные кавычки, забытый параметр). ORM генерирует корректные запросы автоматически, что уменьшает риск таких ошибок.

#### Упрощает переносимость приложения между различными СУБД:

Приложение на ORM можно относительно легко переключить с одной СУБД (например, SQLite) на другую (например, PostgreSQL или MySQL), изменив всего лишь настройки подключения. А вот если писать чистые SQL-запросы, нужно учитывать особенности синтаксиса разных баз данных.

#### Повышает безопасность за счёт автоматической обработки параметров запросов и предотвращения SQL-инъекций:

SQL-инъекция — это уязвимость, при которой злоумышленник может подставить вредоносный SQL-код в параметры запроса. ORM экранирует параметры запросов автоматически, предотвращая возможность инъекций.

#### Обеспечивает единый стиль работы с данными на уровне объектно-ориентированного программирования:

Вместо работы с таблицами и строками из базы в виде списков или кортежей, ORM позволяет работать с объектами классов
Это удобнее, так как можно использовать методы, наследование, инкапсуляцию и другие ООП-принципы.

## **НЕДОСТАТКИ ORM**

#### Может генерировать не оптимальные SQL-запросы, что снижает производительность при работе с большими объемами данных:

ORM автоматически создает SQL-запросы на основе операций с объектами. Иногда эти запросы оказываются неоптимальными с точки зрения работы базы данных — например, из-за избыточных JOIN'ов, выборки всех полей вместо
нужных, или многократных запросов в цикле (так называемая проблема N+1 запросов).

Пример:
Допустим, у нас есть таблица пользователей и связанных с ними заказов.
```python 
users = session.query(User).all()
for user in users:
    print(user.orders)
```
1 запрос на каждый список заказов для каждого пользователя Если пользователей 1000 — получится 1001 запрос. Это сильно нагружает базу и замедляет приложение.

Решение:
Использовать *joinedload* или *subqueryload* для предварительной
подгрузки связанных объектов:
```python
from sqlalchemy.orm import joinedload
users = session.query(User).options(joinedload(User.orders)).all()
```
Так будет один объединённый запрос с JOIN.

#### Требует изучения и настройки:

Чтобы грамотно пользоваться ORM, нужно освоить его синтаксис, концепции (сессии, модели, связи, миграции) и методы настройки. Это требует времени и опыта, особенно если проект сложный.

Чтобы работать c ORM:
- нужно изучить синтаксис моделей, как задавать поля и связи 
- освоить работу с сессиями
- понять принципы lazy-loading и eager-loading 
- научиться делать миграции структуры таблиц

Если нужно только выполнить несколько простых SQL-запросов, возможно, ORM будет излишним и займёт больше времени на настройку, чем написание SQL напрямую.

####Усложняет выполнение нестандартных или сложных запросов:

ORM отлично справляется с типовыми CRUD-операциями и простыми выборками. Но если нужно сделать запрос со сложной вложенной подзапросной логикой, оконными функциями или специфическими оптимизациями, сделать это через
ORM иногда либо очень неудобно, либо невозможно без использования сырого SQL.

Пример:
```sql
SELECT
  u.name,
  COUNT(o.id) AS orders_count
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
GROUP BY u.name
HAVING COUNT(o.id) > 5
ORDER BY orders_count DESC
```

Через ORM такой запрос описать будет либо очень громоздко, либо придётся подключать text() и писать сырой SQL:
```python 
session.execute(text("""
SELECT u.name, COUNT(o.id) AS orders_count
FROM users u
LEFT JOIN orders o ON o.user_id = u.id
GROUP BY u.name
HAVING COUNT(o.id) > 5
ORDER BY orders_count DESC
"""))
```
Это уже снижает преимущество ORM в лаконичности и универсальности.

#### Может скрывать детали работы с базой данных, что затрудняет отладку:

Поскольку ORM автоматически формирует SQL-запросы "за кулисами", разработчик не всегда видит, какой именно запрос уходит в базу данных. Это мешает анализировать и оптимизировать работу с базой, особенно когда производительность падает. ORM иногда выполняет запросы "лениво" (только когда к данным обращаются). Это может приводить к неожиданным задержкам или N+1-запросам.

## **ПРИМЕРЫ** **ПОПУЛЯРНЫХ** **ORM**

Для Python: Django ORM, SQLAlchemy, Peewee;

Для Java: Hibernate, EclipseLink;

Для PHP: Eloquent (Laravel), Doctrine;

Для .NET: Entity Framework, NHibernate.

## **ПРИНЦИП** **РАБОТЫ** **ORM**

ORM использует метаданные о классах и их свойствах для генерации SQL-запросов. При выполнении запроса к базе данных ORM преобразует объекты в строки таблиц, а результаты запросов — в объекты.

Например, при выполнении метода save() объекта ORM формирует SQL-запрос INSERT или UPDATE в зависимости от того, новый это объект или уже существующий.

#### Связь между объектами и таблицами:

ORM позволяет определять связи между классами, которые отражают связи между таблицами в базе данных.

Пример:
Есть две таблицы “User” и “Profile”. Каждый пользователь имеет один профиль.
В ORM это можно отразить так:
```python 
class User(models.Model):
    username = models.CharField(max_length=100)


class Profile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE)
    bio = models.TextField()
```

Использование ORM упрощает выполнение операций с данными. Вместо написания SQL-запросов можно использовать методы и свойства объектов.
Например, чтобы получить всех пользователей:

```python 
users = User.objects.all()
```
Чтобы создать нового пользователя:
```python 
user = User(username="Roman")
user.save()
```
Таким образом, ORM обеспечивает более высокоуровневый и удобный способ работы с базой данных, сокращая количество рутинного кода и повышая читаемость приложения.

### **УПРАВЛЕНИЕ МИГРАЦИЯМИ**

Миграции — это способ зафиксировать и применить изменения структуры базы данных (добавление столбцов, удаление таблиц, изменение типов данных и т.д.) с сохранением истории этих изменений.

ORM обычно включает в себя встроенные или сторонние инструменты миграций, которые:

- отслеживают изменения моделей
- генерируют SQL-скрипты на их основе ● применяют эти изменения к базе
- позволяют откатывать изменения при необходимости

Зачем нужны миграции?

- Чтобы избежать «рассинхронизации» структуры базы между
- разработчиками и серверами. ● Чтобы контролировать изменения базы в
- проекте через систему версионирования кода.


В Django управление миграциями встроено:

`python manage.py makemigrations`
Эта команда создаёт файл миграции на основе изменений моделей.

Применение миграции:
`python manage.py migrate`

У SQLAlchemy миграции выполняются сторонним инструментом Alembic.
Инициализация Alembic:
`alembic init alembic`

Создание миграции:
`alembic revision --autogenerate -m "Added age column to user"`

Применение миграции:
`alembic upgrade head`

Alembic автоматически сравнивает текущее состояние моделей и базы, и формирует нужные изменения.

### **РАБОТА С ТРАНЗАКЦИЯМИ**

Транзакция — это последовательность операций с базой, которая выполняется как единое целое. Либо все операции проходят успешно, либо в случае ошибки все изменения откатываются.

Почему это важно?

- Гарантия целостности данных.
- Позволяет группировать несколько операций в атомарную единицу.

Пример:
Django ORM
Пример:
```python 
from django.db import transaction

try:
    with transaction.atomic():
        user = User.objects.create(name="Леонид", email="lenya@mail.ru")
        # Если следующая строка вызовет исключение -- всё выше будет отменено
        raise ValueError("Ошибка")
except:
    print("Транзакция откатилась")
```    

С помощью with transaction.atomic() открывается транзакция, в рамках которой создаётся пользователь. Изменения остаются в ожидании коммита. Затем намеренно выбрасывается исключение, из-за которого Django автоматически откатывает
все изменения в этой транзакции. В итоге пользователь не сохраняется в базе. Такой подход гарантирует: либо все операции внутри блока выполняются успешно, либо при ошибке всё отменяется, предотвращая частичные записи.

## **ОСНОВНЫЕ** **КОМАНДЫ** **И** **ФУНКЦИИ** **ORM**

Рассмотрим основные функции работы с базой данных на примере **Django** **ORM** — встроенного инструмента в Django для взаимодействия с реляционными базами данных (PostgreSQL, MySQL, SQLite и др.)

.filter() - фильтрует записи по заданным условиям.
Пример:
```python
User.objects.filter(name="Леонид")
```

.get() - получает одну запись по условию или первичному ключу,
возвращает объект или выбрасывает исключение
Пример:
```python 
User.objects.get(pk=1)
```

.all() - возвращает все записи модели.
Пример:
```python 
User.objects.all()
```

.first() - возвращает первый объект из QuerySet. Ограничивает выборку до
первого результата
Пример:
 ```python 
 User.objects.filter(email\_\_contains="gmail.com").first()
```

.create() - создаёт и сохраняет новый объект в БД
Пример:
```python 
User.objects.create(name="Коля", email="kolya@mail.ru")
```

.save() - сохраняет изменения объекта в базу данных
Пример:
```python 
user = User.objects.get(pk=1)
user.name = "Леонид Петров"
user.save()
```

.delete() - удаляет объект из базы данных
Пример:
```python 
user.delete()
```

.order_by() - сортирует записи по полю
Пример:
```python
User.objects.all().order_by('-name')
```

.select_related() - оптимизирует запросы для связанных ForeignKey/OneToOne полей
Пример:
```python 
Profile.objects.select_related('user').all()
```

.prefetch_related() - предварительно загружает данные по связи ManyToMany или обратным ForeignKey
Пример:
```python 
Course.objects.prefetch_related('students').all()
```

## **ПРАКТИЧЕСКИЕ ЗАДАНИЯ ПО ТЕМЕ ORM**

#### **Задание 1: переписать SQL-запрос на ORM.**
SQL-запрос:
```sql
SELECT FROM users WHERE email = 'asya@mail.ru';
```
Решение:
```python 
user = User.objects.get(email="asya@mail.ru")
```

#### **Задание 2: создать нового пользователя через ORM**
**Дано:** таблица User с полями name, email
Решение:
```python
new_user = User(name="Леонид", email="biglenya@mail.ru")
new_user.save()
```

#### **Задание 3: описать связь «один ко многим» между авторами и книгами. У одного автора может быть много книг, у книги — один автор**
Решение:
```python 
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name="books")
```

#### **Задание 4: выбрать все книги автора с именем «Федор»**
Решение:
```python
fedor = Author.objects.get(name="Федорг")
books = fedor.books.all()
```
#### **Задание 5: реализовать транзакцию. Создать двух пользователей, а затем вызвать исключение. Если в процессе возникнет ошибка, оба пользователя не должны сохраниться.**
Решение:
```python 
from django.db import transaction

try:
    with transaction.atomic():
        User.objects.create(name="Дмитрий", email="Dimasik@gmail.com")
        User.objects.create(name="Федя", email="fedka123@gmail.com")
        raise ValueError("Ой… Что-то пошло не так")
except:
    print("Транзакция откатилась")
```

#### **Задание 6: создать миграцию после добавления поля age в модель User.**
Решение:
Добавить в модель:
```python 
age = models.IntegerField(null=**True**)
```
Создать миграцию:
`python manage.py makemigrations`
Применить миграцию:
`python manage.py migrate`
